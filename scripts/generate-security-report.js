#!/usr/bin/env node

/**
 * 📊 Generate Security Report
 * Creates human-readable security reports from JSON analysis results
 */

const fs = require('fs').promises;
const path = require('path');

class SecurityReportGenerator {
    constructor(options = {}) {
        this.inputPath = options.inputPath;
        this.outputPath = options.outputPath;
        this.format = options.format || 'markdown';
    }

    /**
     * Generate security report
     */
    async generateReport() {
        try {
            console.log('📊 Generating security report...');
            
            // Load analysis data
            const analysisData = await this.loadAnalysisData();
            
            // Generate report based on format
            let report;
            switch (this.format.toLowerCase()) {
                case 'markdown':
                    report = this.generateMarkdownReport(analysisData);
                    break;
                case 'html':
                    report = this.generateHtmlReport(analysisData);
                    break;
                case 'json':
                    report = this.generateJsonReport(analysisData);
                    break;
                default:
                    throw new Error(`Unsupported format: ${this.format}`);
            }
            
            // Save report
            if (this.outputPath) {
                await fs.writeFile(this.outputPath, report);
                console.log(`📄 Report saved to: ${this.outputPath}`);
            } else {
                console.log(report);
            }
            
        } catch (error) {
            console.error('❌ Error generating security report:', error);
            throw error;
        }
    }

    /**
     * Load analysis data from input file
     */
    async loadAnalysisData() {
        try {
            const content = await fs.readFile(this.inputPath, 'utf8');
            return JSON.parse(content);
        } catch (error) {
            console.error(`❌ Could not load analysis data from ${this.inputPath}:`, error);
            throw error;
        }
    }

    /**
     * Generate Markdown report
     */
    generateMarkdownReport(data) {
        const timestamp = new Date(data.metadata.timestamp).toLocaleString();
        
        let report = `# 🛡️ AI-Powered Security Analysis Report\n\n`;
        
        // Header
        report += `**Repository:** ${data.metadata.repository}\n`;
        report += `**Branch:** ${data.metadata.branch}\n`;
        report += `**Commit:** ${data.metadata.commit}\n`;
        if (data.metadata.prNumber) {
            report += `**Pull Request:** #${data.metadata.prNumber}\n`;
        }
        report += `**Analysis Date:** ${timestamp}\n`;
        report += `**Bedrock Agent:** ${data.metadata.agentId}\n\n`;
        
        // Executive Summary
        report += `## 📋 Executive Summary\n\n`;
        report += this.generateExecutiveSummary(data);
        
        // Vulnerability Summary
        report += `## 🚨 Vulnerability Summary\n\n`;
        report += this.generateVulnerabilitySummary(data);
        
        // File Analysis
        report += `## 📁 File Analysis\n\n`;
        report += this.generateFileAnalysis(data);
        
        // Overall Analysis
        if (data.overallAnalysis) {
            report += `## 🔍 Overall Security Analysis\n\n`;
            report += this.generateOverallAnalysis(data.overallAnalysis);
        }
        
        // Recommendations
        if (data.recommendations && data.recommendations.length > 0) {
            report += `## 💡 Recommendations\n\n`;
            report += this.generateRecommendations(data.recommendations);
        }
        
        // Compliance
        if (data.compliance) {
            report += `## 📜 Compliance Status\n\n`;
            report += this.generateComplianceStatus(data.compliance);
        }
        
        // Footer
        report += `\n---\n`;
        report += `*Report generated by AI-Powered DevSecOps Security Analysis Pipeline*\n`;
        report += `*Powered by AWS Bedrock with Claude 3.5 Sonnet*\n`;
        
        return report;
    }

    /**
     * Generate executive summary
     */
    generateExecutiveSummary(data) {
        const summary = this.calculateSummaryStats(data);
        
        let summaryText = `This security analysis examined **${summary.totalFiles}** files `;
        summaryText += `with **${summary.totalVulnerabilities}** security issues identified.\n\n`;
        
        summaryText += `### 🎯 Key Findings\n\n`;
        summaryText += `- **Critical Issues:** ${summary.critical}\n`;
        summaryText += `- **High Priority Issues:** ${summary.high}\n`;
        summaryText += `- **Medium Priority Issues:** ${summary.medium}\n`;
        summaryText += `- **Low Priority Issues:** ${summary.low}\n\n`;
        
        summaryText += `### 📊 Security Score: ${summary.securityScore}/100\n\n`;
        
        if (summary.critical > 0) {
            summaryText += `🚨 **CRITICAL ALERT:** ${summary.critical} critical security issues require immediate attention!\n\n`;
        } else if (summary.high > 0) {
            summaryText += `⚠️ **HIGH PRIORITY:** ${summary.high} high-priority issues should be addressed soon.\n\n`;
        } else if (summary.medium > 0) {
            summaryText += `ℹ️ **MEDIUM PRIORITY:** ${summary.medium} medium-priority issues should be planned for resolution.\n\n`;
        } else {
            summaryText += `✅ **GOOD SECURITY POSTURE:** No critical or high-priority issues found.\n\n`;
        }
        
        return summaryText;
    }

    /**
     * Generate vulnerability summary
     */
    generateVulnerabilitySummary(data) {
        const summary = this.calculateSummaryStats(data);
        
        let summaryText = `| Severity | Count | Status |\n`;
        summaryText += `|----------|-------|--------|\n`;
        summaryText += `| 🔴 Critical | ${summary.critical} | ${summary.critical > 0 ? '❌ Needs Attention' : '✅ None'} |\n`;
        summaryText += `| 🟠 High | ${summary.high} | ${summary.high > 0 ? '⚠️ Review Required' : '✅ None'} |\n`;
        summaryText += `| 🟡 Medium | ${summary.medium} | ${summary.medium > 0 ? 'ℹ️ Plan to Fix' : '✅ None'} |\n`;
        summaryText += `| 🟢 Low | ${summary.low} | ${summary.low > 0 ? 'ℹ️ Monitor' : '✅ None'} |\n`;
        summaryText += `| **Total** | **${summary.totalVulnerabilities}** | **${summary.securityScore}/100** |\n\n`;
        
        return summaryText;
    }

    /**
     * Generate file analysis section
     */
    generateFileAnalysis(data) {
        if (!data.fileAnalysis || data.fileAnalysis.length === 0) {
            return `No file analysis data available.\n\n`;
        }
        
        let analysisText = `### 📁 Analyzed Files\n\n`;
        
        data.fileAnalysis.forEach((fileAnalysis, index) => {
            if (fileAnalysis.analysis) {
                try {
                    const parsed = JSON.parse(fileAnalysis.analysis);
                    
                    analysisText += `#### ${index + 1}. ${fileAnalysis.file}\n\n`;
                    
                    if (parsed.vulnerabilities && parsed.vulnerabilities.length > 0) {
                        analysisText += `**Vulnerabilities Found:** ${parsed.vulnerabilities.length}\n\n`;
                        
                        parsed.vulnerabilities.forEach((vuln, vulnIndex) => {
                            const severityEmoji = this.getSeverityEmoji(vuln.severity);
                            analysisText += `${vulnIndex + 1}. ${severityEmoji} **${vuln.severity}**: ${vuln.type}\n`;
                            analysisText += `   - **Description:** ${vuln.description}\n`;
                            if (vuln.line) {
                                analysisText += `   - **Line:** ${vuln.line}\n`;
                            }
                            if (vuln.owasp_category) {
                                analysisText += `   - **OWASP:** ${vuln.owasp_category}\n`;
                            }
                            if (vuln.cwe_id) {
                                analysisText += `   - **CWE:** ${vuln.cwe_id}\n`;
                            }
                            analysisText += `   - **Remediation:** ${vuln.remediation}\n\n`;
                        });
                    } else {
                        analysisText += `✅ No security vulnerabilities found in this file.\n\n`;
                    }
                    
                    if (parsed.best_practices && parsed.best_practices.length > 0) {
                        analysisText += `**Best Practices:**\n`;
                        parsed.best_practices.forEach(practice => {
                            analysisText += `- ${practice}\n`;
                        });
                        analysisText += `\n`;
                    }
                    
                } catch (e) {
                    // Handle parsing errors - show raw analysis
                    analysisText += `#### ${index + 1}. ${fileAnalysis.file}\n\n`;
                    analysisText += `**Analysis:**\n\`\`\`\n${fileAnalysis.analysis}\n\`\`\`\n\n`;
                }
            }
        });
        
        return analysisText;
    }

    /**
     * Generate overall analysis section
     */
    generateOverallAnalysis(overallAnalysis) {
        try {
            const parsed = JSON.parse(overallAnalysis);
            
            let analysisText = `### 🎯 Overall Security Assessment\n\n`;
            
            if (parsed.security_score !== undefined) {
                analysisText += `**Security Score:** ${parsed.security_score}/100\n\n`;
            }
            
            if (parsed.risk_level) {
                const riskEmoji = this.getRiskEmoji(parsed.risk_level);
                analysisText += `**Risk Level:** ${riskEmoji} ${parsed.risk_level}\n\n`;
            }
            
            if (parsed.summary) {
                analysisText += `**Summary:**\n${parsed.summary}\n\n`;
            }
            
            if (parsed.recommended_actions && parsed.recommended_actions.length > 0) {
                analysisText += `**Recommended Actions:**\n`;
                parsed.recommended_actions.forEach((action, index) => {
                    analysisText += `${index + 1}. ${action}\n`;
                });
                analysisText += `\n`;
            }
            
            return analysisText;
            
        } catch (e) {
            // Handle parsing errors - show raw analysis
            return `### 🔍 Overall Analysis\n\n\`\`\`\n${overallAnalysis}\n\`\`\`\n\n`;
        }
    }

    /**
     * Generate recommendations section
     */
    generateRecommendations(recommendations) {
        let recText = `### 💡 Priority Recommendations\n\n`;
        
        recommendations.forEach((rec, index) => {
            recText += `${index + 1}. ${rec}\n`;
        });
        
        recText += `\n`;
        return recText;
    }

    /**
     * Generate compliance status section
     */
    generateComplianceStatus(compliance) {
        let complianceText = `### 📜 Compliance Framework Status\n\n`;
        
        complianceText += `| Framework | Status |\n`;
        complianceText += `|-----------|--------|\n`;
        
        Object.entries(compliance).forEach(([framework, status]) => {
            const statusEmoji = this.getComplianceEmoji(status);
            complianceText += `| ${framework.toUpperCase()} | ${statusEmoji} ${status} |\n`;
        });
        
        complianceText += `\n`;
        return complianceText;
    }

    /**
     * Calculate summary statistics
     */
    calculateSummaryStats(data) {
        const stats = {
            totalFiles: data.summary?.totalFilesAnalyzed || 0,
            totalVulnerabilities: 0,
            critical: 0,
            high: 0,
            medium: 0,
            low: 0,
            securityScore: 100
        };

        // Count vulnerabilities from file analysis
        if (data.fileAnalysis) {
            data.fileAnalysis.forEach(analysis => {
                if (analysis.analysis) {
                    try {
                        const parsed = JSON.parse(analysis.analysis);
                        if (parsed.vulnerabilities) {
                            parsed.vulnerabilities.forEach(vuln => {
                                const severity = vuln.severity?.toLowerCase() || 'low';
                                if (stats[severity] !== undefined) {
                                    stats[severity]++;
                                    stats.totalVulnerabilities++;
                                }
                            });
                        }
                    } catch (e) {
                        // Handle parsing errors
                    }
                }
            });
        }

        // Add counts from overall analysis
        if (data.overallAnalysis) {
            try {
                const parsed = JSON.parse(data.overallAnalysis);
                if (parsed.critical_issues) stats.critical += parsed.critical_issues;
                if (parsed.high_issues) stats.high += parsed.high_issues;
                if (parsed.medium_issues) stats.medium += parsed.medium_issues;
                if (parsed.low_issues) stats.low += parsed.low_issues;
                if (parsed.security_score !== undefined) stats.securityScore = parsed.security_score;
            } catch (e) {
                // Handle parsing errors
            }
        }

        return stats;
    }

    /**
     * Get severity emoji
     */
    getSeverityEmoji(severity) {
        const emojiMap = {
            'critical': '🔴',
            'high': '🟠',
            'medium': '🟡',
            'low': '🟢'
        };
        return emojiMap[severity?.toLowerCase()] || '⚪';
    }

    /**
     * Get risk emoji
     */
    getRiskEmoji(riskLevel) {
        const emojiMap = {
            'critical': '🚨',
            'high': '⚠️',
            'medium': 'ℹ️',
            'low': '✅'
        };
        return emojiMap[riskLevel?.toLowerCase()] || '❓';
    }

    /**
     * Get compliance emoji
     */
    getComplianceEmoji(status) {
        const emojiMap = {
            'pass': '✅',
            'fail': '❌',
            'partial': '⚠️'
        };
        return emojiMap[status?.toLowerCase()] || '❓';
    }

    /**
     * Generate HTML report
     */
    generateHtmlReport(data) {
        // Implementation for HTML report generation
        return '<html><body>HTML report not yet implemented</body></html>';
    }

    /**
     * Generate JSON report
     */
    generateJsonReport(data) {
        return JSON.stringify(data, null, 2);
    }
}

// CLI Interface
async function main() {
    const args = process.argv.slice(2);
    const options = {};
    
    // Parse command line arguments
    for (let i = 0; i < args.length; i++) {
        switch (args[i]) {
            case '--input':
                options.inputPath = args[++i];
                break;
            case '--output':
                options.outputPath = args[++i];
                break;
            case '--format':
                options.format = args[++i];
                break;
        }
    }
    
    if (!options.inputPath) {
        console.error('❌ Error: --input path is required');
        process.exit(1);
    }
    
    try {
        const generator = new SecurityReportGenerator(options);
        await generator.generateReport();
        console.log('✅ Security report generated successfully!');
        
    } catch (error) {
        console.error('❌ Error generating security report:', error);
        process.exit(1);
    }
}

// Export for use as module
module.exports = SecurityReportGenerator;

// Run if called directly
if (require.main === module) {
    main();
}
